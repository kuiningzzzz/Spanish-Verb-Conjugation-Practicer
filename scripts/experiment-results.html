<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>实验结果分析</title>
  <style>
    :root {
      --bg: #f4f6fb;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    button,
    input,
    label {
      font-family: inherit;
    }

    button {
      cursor: pointer;
      background: var(--primary);
      color: #ffffff;
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(37, 99, 235, 0.2);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button.danger {
      background: #dc2626;
    }

    button.danger:hover {
      box-shadow: 0 8px 16px rgba(220, 38, 38, 0.2);
    }

    .content {
      max-width: 1240px;
      margin: 0 auto;
      padding: 24px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.06);
    }

    .muted {
      color: var(--muted);
    }

    .error {
      margin: 0;
      color: #b91c1c;
      font-weight: 600;
    }

    .success-message {
      margin: 0;
      color: #166534;
      font-weight: 600;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      margin: 0;
    }

    .users-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      width: 100%;
    }

    .upload-toolbar {
      justify-content: flex-end;
    }

    .upload-input {
      display: none;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: #e2e8f0;
      color: #0f172a;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .table th,
    .table td {
      padding: 12px 10px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      vertical-align: middle;
    }

    .table th {
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      font-size: 12px;
    }

    .compact-table th,
    .compact-table td {
      padding: 8px 10px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }

    .stat-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      background: #f8fafc;
    }

    .stat-card h3 {
      margin: 0 0 8px;
      font-size: 14px;
      color: var(--muted);
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 6px;
    }

    .empty {
      padding: 24px;
      text-align: center;
      color: var(--muted);
    }

    .experiment-page {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .entry-section h3 {
      margin: 0 0 10px;
    }

    .entry-accordion {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .accordion-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: #ffffff;
    }

    .accordion-item.selected {
      border-color: #93c5fd;
      box-shadow: 0 0 0 2px rgba(147, 197, 253, 0.25);
    }

    .accordion-header {
      width: 100%;
      border: none;
      background: #ffffff;
      color: var(--text);
      border-radius: 0;
      padding: 12px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      text-align: left;
    }

    .accordion-header:hover {
      transform: none;
      box-shadow: none;
      background: #f8fafc;
    }

    .accordion-main {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .accordion-sub {
      font-size: 13px;
    }

    .accordion-meta {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .accordion-arrow {
      width: 16px;
      font-size: 18px;
      font-weight: 700;
      color: var(--muted);
      text-align: center;
    }

    .accordion-body {
      border-top: 1px solid var(--border);
      background: #f8fafc;
      padding: 12px 14px 14px;
    }

    .accordion-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .entry-file {
      font-weight: 600;
      max-width: 360px;
      word-break: break-all;
    }

    .viewer {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      background: #f8fafc;
    }

    .viewer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .viewer-header h3 {
      margin: 0 0 4px;
      word-break: break-all;
    }

    .viewer-header p {
      margin: 0;
    }

    .viewer-mode-switch {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .mode-btn.active {
      background: #2563eb;
      border-color: #2563eb;
      color: #ffffff;
    }

    .row-nav {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 8px 0 10px;
    }

    .detail-filter-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin: 8px 0 10px;
    }

    .filter-checkbox {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--text);
    }

    .filter-checkbox input {
      margin: 0;
    }

    .filter-summary {
      margin-left: auto;
      font-size: 13px;
    }

    .filter-select-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--text);
    }

    .filter-select {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      background: #ffffff;
      color: var(--text);
      min-width: 128px;
    }

    .row-meta {
      margin: 2px 0 12px;
      font-size: 13px;
    }

    .stage-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .stage-tab {
      background: #ffffff;
      border: 1px solid var(--border);
      color: var(--text);
    }

    .stage-tab.active {
      background: #2563eb;
      color: #ffffff;
      border-color: #2563eb;
    }

    .slider-wrapper {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
    }

    .slider-arrow {
      width: 44px;
      height: 44px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      padding: 0;
    }

    .slider-viewport {
      overflow: hidden;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
    }

    .slider-track {
      display: flex;
      transition: transform 0.24s ease;
      width: 100%;
    }

    .stage-pane {
      flex: 0 0 100%;
      min-height: 560px;
      max-height: 560px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stage-header h4 {
      margin: 0;
    }

    .stage-header p {
      margin: 4px 0 0;
    }

    .stage-body {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .detail-label {
      font-size: 13px;
      font-weight: 700;
    }

    .field-value {
      margin: 0;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #f8fafc;
      padding: 10px;
      min-height: 72px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.5;
      font-family: inherit;
    }

    .field-value.empty {
      color: var(--muted);
    }

    .analysis-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
    }

    .analysis-heading h4 {
      margin: 0;
    }

    .analysis-heading p {
      margin: 6px 0 0;
    }

    .analysis-kpis {
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 6px;
    }

    .analysis-kpis .stat-card {
      padding: 10px;
      border-radius: 10px;
    }

    .analysis-kpis .stat-card h3 {
      margin: 0 0 4px;
      font-size: 12px;
    }

    .analysis-kpis .stat-value {
      margin: 0;
      font-size: 18px;
      line-height: 1.2;
    }

    .analysis-kpis .muted {
      margin-top: 2px;
      font-size: 12px;
    }

    .analysis-table-wrap {
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
      max-height: 320px;
      overflow: auto;
    }

    .analysis-table-wrap h4 {
      margin: 0 0 10px;
    }

    @media (max-width: 960px) {
      .content {
        padding: 16px;
      }

      .slider-wrapper {
        grid-template-columns: 1fr;
      }

      .slider-arrow {
        justify-self: center;
      }

      .stage-pane {
        min-height: 520px;
        max-height: 520px;
      }
    }
  </style>
</head>
<body>
  <main class="content">
    <section class="card experiment-page">
      <div id="app"></div>
    </section>
  </main>

  <script>
    (function () {
      const STORAGE_KEY = 'admin_experiment_results_v1';

      const EMPTY_FILTER_VALUE = '__EMPTY_FILTER__';

      const LEGACY_REQUIRED_HEADERS = [
        'verb_infinitive',
        'verb_meaning',
        'conjugation_mood',
        'conjugation_tense',
        'conjugation_person',
        'conjugation_form',
        'question_sentence',
        'question_answer',
        'question_translation',
        'question_hint',
        'question_error',
        'revised_sentence',
        'revisor_reason',
        'revised_question_error',
        'generator_prompt_index',
        'generator_model',
        'generator_temperature',
        'validator_used',
        'validator_prompt_index',
        'revisor_used',
        'revisor_prompt_index',
        'revisor_temperature',
        'validator_1_is_valid',
        'validator_1_has_unique_answer',
        'validator_1_reason',
        'validator_1_rewrite_advice',
        'validator_2_is_valid',
        'validator_2_has_unique_answer',
        'validator_2_reason',
        'validator_2_rewrite_advice',
        'validator_is_valid',
        'validator_has_unique_answer',
        'validator_reason',
        'validator_rewrite_advice'
      ];

      const PRONOUN_REQUIRED_HEADERS = [
        'verb_infinitive',
        'verb_meaning',
        'host_form',
        'host_form_zh',
        'pronoun_pattern',
        'mood',
        'tense',
        'person',
        'io_pronoun',
        'do_pronoun',
        'question_sentence',
        'question_answer',
        'question_translation',
        'question_hint',
        'revised_sentence',
        'revisor_reason',
        'generator_prompt_index',
        'generator_model',
        'generator_temperature',
        'validator_used',
        'validator_prompt_index',
        'validator_model',
        'validator_temperature',
        'revisor_used',
        'revisor_prompt_index',
        'revisor_model',
        'revisor_temperature',
        'validator_1_is_valid',
        'validator_1_has_unique_answer',
        'validator_1_reason',
        'validator_1_rewrite_advice',
        'validator_2_is_valid',
        'validator_2_has_unique_answer',
        'validator_2_reason',
        'validator_2_rewrite_advice',
        'validator_is_valid',
        'validator_has_unique_answer',
        'validator_reason',
        'validator_rewrite_advice',
        'error'
      ];

      const FIELD_LABELS = {
        verb_infinitive: '动词原形',
        verb_meaning: '动词释义',
        conjugation_mood: '变位语气',
        conjugation_tense: '变位时态',
        conjugation_person: '变位人称',
        conjugation_form: '目标变位',
        question_sentence: '题干句子',
        question_answer: '题目答案',
        question_translation: '中文翻译',
        question_hint: '提示',
        question_error: '生成错误',
        revised_sentence: '重写句子',
        revisor_reason: '重写理由',
        revised_question_error: '重写错误',
        generator_prompt_index: 'Generator Prompt 序号',
        generator_model: 'Generator 模型',
        generator_temperature: 'Generator 温度',
        validator_used: '是否启用 Validator',
        validator_prompt_index: 'Validator Prompt 序号',
        revisor_used: '是否启用 Revisor',
        revisor_prompt_index: 'Revisor Prompt 序号',
        revisor_temperature: 'Revisor 温度',
        validator_1_is_valid: 'Validator-1 是否有效',
        validator_1_has_unique_answer: 'Validator-1 是否唯一解',
        validator_1_reason: 'Validator-1 原因',
        validator_1_rewrite_advice: 'Validator-1 重写建议',
        validator_2_is_valid: 'Validator-2 是否有效',
        validator_2_has_unique_answer: 'Validator-2 是否唯一解',
        validator_2_reason: 'Validator-2 原因',
        validator_2_rewrite_advice: 'Validator-2 重写建议',
        validator_is_valid: '最终校验是否有效',
        validator_has_unique_answer: '最终校验是否唯一解',
        validator_reason: '最终校验原因',
        validator_rewrite_advice: '最终校验建议',
        host_form: 'host_form',
        host_form_zh: 'host_form 中文',
        pronoun_pattern: 'pronoun_pattern',
        mood: '语气',
        tense: '时态',
        person: '人称',
        io_pronoun: 'IO 代词',
        do_pronoun: 'DO 代词',
        validator_model: 'Validator 模型',
        validator_temperature: 'Validator 温度',
        revisor_model: 'Revisor 模型',
        error: '错误'
      };

      const SCHEMA_CONFIG = {
        legacy_conjugation: {
          key: 'legacy_conjugation',
          label: '传统变位实验',
          requiredHeaders: LEGACY_REQUIRED_HEADERS,
          rowMetaFields: [
            { key: 'conjugation_tense', label: '时态' },
            { key: 'conjugation_person', label: '人称' }
          ],
          filterFields: [
            { key: 'conjugation_person', label: '人称', allLabel: '全部人称', emptyLabel: '空人称' },
            { key: 'conjugation_tense', label: '时态', allLabel: '全部时态', emptyLabel: '空时态' }
          ],
          analysisDimensions: [
            { key: 'conjugation_person', title: '各人称通过率', columnLabel: '人称', emptyText: '无人称数据', fallback: '未标注人称' },
            { key: 'conjugation_tense', title: '各时态通过率', columnLabel: '时态', emptyText: '无时态数据', fallback: '未标注时态' }
          ],
          stages: [
            {
              key: 'generator',
              title: 'Generator 输出',
              description: '题目生成与基础上下文字段',
              fields: [
                'verb_infinitive',
                'verb_meaning',
                'conjugation_mood',
                'conjugation_tense',
                'conjugation_person',
                'conjugation_form',
                'question_sentence',
                'question_answer',
                'question_translation',
                'question_hint',
                'question_error',
                'generator_prompt_index',
                'generator_model',
                'generator_temperature'
              ]
            },
            {
              key: 'validator_1',
              title: 'Validator-1 输出',
              description: '第一轮校验结果',
              fields: [
                'validator_used',
                'validator_prompt_index',
                'validator_1_is_valid',
                'validator_1_has_unique_answer',
                'validator_1_reason',
                'validator_1_rewrite_advice'
              ]
            },
            {
              key: 'revisor',
              title: 'Revisor 输出',
              description: '重写与修正结果',
              fields: [
                'revisor_used',
                'revisor_prompt_index',
                'revisor_temperature',
                'revised_sentence',
                'revisor_reason',
                'revised_question_error'
              ]
            },
            {
              key: 'validator_2',
              title: 'Validator-2 输出',
              description: '第二轮校验与最终结论',
              fields: [
                'validator_2_is_valid',
                'validator_2_has_unique_answer',
                'validator_2_reason',
                'validator_2_rewrite_advice',
                'validator_is_valid',
                'validator_has_unique_answer',
                'validator_reason',
                'validator_rewrite_advice'
              ]
            }
          ]
        },
        conjugation_with_pronoun: {
          key: 'conjugation_with_pronoun',
          label: '动词+代词实验',
          requiredHeaders: PRONOUN_REQUIRED_HEADERS,
          rowMetaFields: [
            { key: 'host_form', label: 'host_form' },
            { key: 'pronoun_pattern', label: 'pronoun_pattern' }
          ],
          filterFields: [
            { key: 'host_form', label: 'host_form', allLabel: '全部 host_form', emptyLabel: '空 host_form' },
            { key: 'pronoun_pattern', label: 'pronoun_pattern', allLabel: '全部 pronoun_pattern', emptyLabel: '空 pronoun_pattern' }
          ],
          analysisDimensions: [
            { key: 'host_form', title: '各 host_form 通过率', columnLabel: 'host_form', emptyText: '无 host_form 数据', fallback: '未标注 host_form' },
            { key: 'pronoun_pattern', title: '各 pronoun_pattern 通过率', columnLabel: 'pronoun_pattern', emptyText: '无 pronoun_pattern 数据', fallback: '未标注 pronoun_pattern' }
          ],
          stages: [
            {
              key: 'generator',
              title: 'Generator 输出',
              description: '题目生成与代词相关字段',
              fields: [
                'verb_infinitive',
                'verb_meaning',
                'host_form',
                'host_form_zh',
                'pronoun_pattern',
                'mood',
                'tense',
                'person',
                'io_pronoun',
                'do_pronoun',
                'question_sentence',
                'question_answer',
                'question_translation',
                'question_hint',
                'generator_prompt_index',
                'generator_model',
                'generator_temperature'
              ]
            },
            {
              key: 'validator_1',
              title: 'Validator-1 输出',
              description: '第一轮校验结果',
              fields: [
                'validator_used',
                'validator_prompt_index',
                'validator_model',
                'validator_temperature',
                'validator_1_is_valid',
                'validator_1_has_unique_answer',
                'validator_1_reason',
                'validator_1_rewrite_advice'
              ]
            },
            {
              key: 'revisor',
              title: 'Revisor 输出',
              description: '重写与修正结果',
              fields: [
                'revisor_used',
                'revisor_prompt_index',
                'revisor_model',
                'revisor_temperature',
                'revised_sentence',
                'revisor_reason'
              ]
            },
            {
              key: 'validator_2',
              title: 'Validator-2 输出',
              description: '第二轮校验与最终结论',
              fields: [
                'validator_2_is_valid',
                'validator_2_has_unique_answer',
                'validator_2_reason',
                'validator_2_rewrite_advice',
                'validator_is_valid',
                'validator_has_unique_answer',
                'validator_reason',
                'validator_rewrite_advice',
                'error'
              ]
            }
          ]
        }
      };

      const SCHEMA_KEYS = Object.keys(SCHEMA_CONFIG);
      const DEFAULT_SCHEMA_KEY = SCHEMA_KEYS[0];

      SCHEMA_KEYS.forEach((schemaKey) => {
        const schema = SCHEMA_CONFIG[schemaKey];
        schema.stageDefs = mapStages(schema.stages);
        schema.knownHeaders = collectSchemaHeaders(schema);
      });

      const appEl = document.getElementById('app');

      const state = {
        entries: loadEntries(),
        activeEntryId: '',
        expandedEntryId: '',
        isViewerVisible: false,
        viewerMode: 'detail',
        filterV1Failed: false,
        filterV2Failed: false,
        detailFieldFilters: {},
        currentRowIndex: 0,
        currentStageIndex: 0,
        currentModelIndex: 0,
        errorMessage: '',
        successMessage: ''
      };

      appEl.addEventListener('click', handleClick);
      appEl.addEventListener('change', handleChange);

      normalizeUiState();
      render();

      function handleClick(event) {
        const trigger = event.target.closest('[data-action]');
        if (!trigger) return;

        const action = trigger.getAttribute('data-action');
        const id = trigger.getAttribute('data-id') || '';

        if (action === 'open-file-picker') {
          const input = appEl.querySelector('#fileInput');
          if (input) input.click();
          return;
        }
        if (action === 'clear-entries') {
          clearEntries();
          return;
        }
        if (action === 'toggle-accordion') {
          toggleEntryAccordion(id);
          return;
        }
        if (action === 'open-entry-detail') {
          openEntry(id, 'detail');
          return;
        }
        if (action === 'open-entry-analysis') {
          openEntry(id, 'analysis');
          return;
        }
        if (action === 'remove-entry') {
          removeEntry(id);
          return;
        }
        if (action === 'set-view-mode') {
          const mode = trigger.getAttribute('data-mode') || 'detail';
          setViewerMode(mode);
          return;
        }
        if (action === 'prev-row') {
          goPrevRow();
          return;
        }
        if (action === 'next-row') {
          goNextRow();
          return;
        }
        if (action === 'go-stage') {
          const index = Number(trigger.getAttribute('data-index'));
          goToStage(index);
          return;
        }
        if (action === 'prev-stage') {
          goPrevStage();
          return;
        }
        if (action === 'next-stage') {
          goNextStage();
          return;
        }
        if (action === 'clear-detail-filters') {
          clearDetailFilters();
          return;
        }
        if (action === 'prev-model') {
          goPrevModel();
          return;
        }
        if (action === 'next-model') {
          goNextModel();
          return;
        }
      }

      function handleChange(event) {
        if (event.target.id === 'fileInput') {
          void handleFileUpload(event);
          return;
        }

        const action = event.target.getAttribute('data-action');
        if (action === 'filter-v1') {
          state.filterV1Failed = !!event.target.checked;
          if (!state.filterV1Failed) {
            state.filterV2Failed = false;
          }
          state.currentRowIndex = 0;
          normalizeUiState();
          render();
          return;
        }
        if (action === 'filter-v2') {
          state.filterV2Failed = !!event.target.checked;
          state.currentRowIndex = 0;
          normalizeUiState();
          render();
          return;
        }
        if (action === 'filter-field') {
          const field = event.target.getAttribute('data-field') || '';
          if (!field) return;
          state.detailFieldFilters[field] = String(event.target.value || '');
          state.currentRowIndex = 0;
          state.currentModelIndex = 0;
          normalizeUiState();
          render();
        }
      }

      function render() {
        const derived = deriveState();
        const activeEntry = derived.activeEntry;
        const entryRows = state.entries
          .map((entry) => {
            const expanded = state.expandedEntryId === entry.id;
            const selected = state.isViewerVisible && state.activeEntryId === entry.id;
            return (
              '<article class="accordion-item' +
              (expanded ? ' expanded' : '') +
              (selected ? ' selected' : '') +
              '">' +
              '<button class="accordion-header" data-action="toggle-accordion" data-id="' +
              escapeHtml(entry.id) +
              '">' +
              '<div class="accordion-main">' +
              '<span class="entry-file">' +
              escapeHtml(entry.fileName) +
              '</span>' +
              '<span class="accordion-sub muted">' +
              escapeHtml(formatDate(entry.uploadedAt)) +
              '</span>' +
              '</div>' +
              '<div class="accordion-meta">' +
              '<span class="tag">' +
              escapeHtml(String(entry.rowCount)) +
              ' 行</span>' +
              '<span class="tag">' +
              escapeHtml(getSchemaLabel(entry.schemaKey)) +
              '</span>' +
              '<span class="accordion-arrow">' +
              (expanded ? '−' : '+') +
              '</span>' +
              '</div>' +
              '</button>' +
              (expanded
                ? '<div class="accordion-body">' +
                  '<div class="accordion-actions">' +
                  '<button class="ghost" data-action="open-entry-detail" data-id="' +
                  escapeHtml(entry.id) +
                  '">查看详情</button>' +
                  '<button class="ghost" data-action="open-entry-analysis" data-id="' +
                  escapeHtml(entry.id) +
                  '">分析结果</button>' +
                  '<button class="danger" data-action="remove-entry" data-id="' +
                  escapeHtml(entry.id) +
                  '">删除</button>' +
                  '</div>' +
                  '</div>'
                : '') +
              '</article>'
            );
          })
          .join('');

        const viewerHtml = renderViewer(derived);
        const emptyEntriesHtml = state.entries.length ? '' : '<div class="empty">暂无上传记录，请先上传 CSV。</div>';

        appEl.innerHTML =
          '<div class="users-header">' +
          '<div>' +
          '<h2>实验结果分析</h2>' +
          '<p class="muted">仅本地分析 CSV，不连接任何后端接口。</p>' +
          '</div>' +
          '<div class="toolbar upload-toolbar">' +
          '<input id="fileInput" class="upload-input" type="file" accept=".csv,text/csv" />' +
          '<button data-action="open-file-picker">上传 CSV</button>' +
          '<button class="ghost" data-action="clear-entries"' +
          (state.entries.length ? '' : ' disabled') +
          '>清空缓存</button>' +
          '</div>' +
          '</div>' +
          '<p class="hint">支持传统变位实验 CSV 与 conjugation_with_pronoun CSV。字段顺序不限，但必须包含对应实验类型的必需字段。</p>' +
          (state.errorMessage ? '<p class="error">' + escapeHtml(state.errorMessage) + '</p>' : '') +
          (state.successMessage ? '<p class="success-message">' + escapeHtml(state.successMessage) + '</p>' : '') +
          '<div class="entry-section">' +
          '<h3>上传条目</h3>' +
          '<div class="entry-accordion">' +
          entryRows +
          emptyEntriesHtml +
          '</div>' +
          '</div>' +
          viewerHtml;

        if (state.isViewerVisible && !activeEntry) {
          state.isViewerVisible = false;
        }
      }

      function renderViewer(derived) {
        if (!state.isViewerVisible || !derived.activeEntry) {
          return '';
        }

        const detailRows = derived.detailRows;
        const activeRows = derived.activeRows;
        const modelStatsPages = derived.modelStatsPages;

        return (
          '<div class="viewer">' +
          '<div class="viewer-header">' +
          '<div>' +
          '<h3>' +
          escapeHtml(state.viewerMode === 'detail' ? '详情' : '分析结果') +
          '：' +
          escapeHtml(derived.activeEntry.fileName) +
          '</h3>' +
          (state.viewerMode === 'detail'
            ? '<p class="muted">第 ' +
              (detailRows.length ? state.currentRowIndex + 1 : 0) +
              ' / ' +
              detailRows.length +
              ' 行 ｜ ' +
              escapeHtml(getSchemaLabel(derived.activeEntry.schemaKey)) +
              '</p>'
            : '<p class="muted">模型页 ' +
              (modelStatsPages.length ? state.currentModelIndex + 1 : 0) +
              ' / ' +
              modelStatsPages.length +
              ' ｜ ' +
              escapeHtml(getSchemaLabel(derived.activeEntry.schemaKey)) +
              '</p>') +
          '</div>' +
          '<div class="viewer-mode-switch">' +
          '<button class="ghost mode-btn' +
          (state.viewerMode === 'detail' ? ' active' : '') +
          '" data-action="set-view-mode" data-mode="detail">查看详情</button>' +
          '<button class="ghost mode-btn' +
          (state.viewerMode === 'analysis' ? ' active' : '') +
          '" data-action="set-view-mode" data-mode="analysis">分析结果</button>' +
          '</div>' +
          '</div>' +
          (!activeRows.length
            ? '<div class="empty">该条目没有可展示的数据行。</div>'
            : state.viewerMode === 'detail'
            ? renderDetailViewer(derived)
            : renderAnalysisViewer(derived)) +
          '</div>'
        );
      }

      function renderDetailViewer(derived) {
        const detailRows = derived.detailRows;
        const currentRow = derived.currentRow;
        const stages = derived.stages;
        const stageTabs = stages.map((stage, index) => {
          return (
            '<button class="stage-tab' +
            (index === state.currentStageIndex ? ' active' : '') +
            '" data-action="go-stage" data-index="' +
            index +
            '">' +
            escapeHtml(stage.title) +
            '</button>'
          );
        }).join('');

        const stagePanes = stages.map((stage) => {
          const fieldItems = stage.fields
            .map((field) => {
              const value = currentRow ? currentRow[field.key] : '';
              return (
                '<div class="detail-item">' +
                '<span class="detail-label">' +
                escapeHtml(field.label) +
                '</span>' +
                '<pre class="field-value' +
                (isEmptyValue(value) ? ' empty' : '') +
                '">' +
                escapeHtml(formatFieldValue(value)) +
                '</pre>' +
                '</div>'
              );
            })
            .join('');

          return (
            '<section class="stage-pane">' +
            '<header class="stage-header">' +
            '<h4>' +
            escapeHtml(stage.title) +
            '</h4>' +
            '<p class="muted">' +
            escapeHtml(stage.description) +
            '</p>' +
            '</header>' +
            '<div class="stage-body">' +
            '<div class="detail-grid">' +
            fieldItems +
            '</div>' +
            '</div>' +
            '</section>'
          );
        }).join('');

        const dimensionFilterControls = derived.dimensionFilterOptions
          .map((filterConfig) => {
            const optionHtml = [
              '<option value="">' + escapeHtml(filterConfig.allLabel) + '</option>'
            ]
              .concat(
                filterConfig.options.map((option) => {
                  return (
                    '<option value="' +
                    escapeHtml(option.value) +
                    '"' +
                    (option.value === filterConfig.currentValue ? ' selected' : '') +
                    '>' +
                    escapeHtml(option.label) +
                    '</option>'
                  );
                })
              )
              .join('');

            return (
              '<label class="filter-select-wrap">' +
              escapeHtml(filterConfig.label) +
              '<select class="filter-select" data-action="filter-field" data-field="' +
              escapeHtml(filterConfig.key) +
              '">' +
              optionHtml +
              '</select>' +
              '</label>'
            );
          })
          .join('');

        return (
          '<div class="detail-filter-bar">' +
          '<label class="filter-checkbox">' +
          '<input type="checkbox" data-action="filter-v1"' +
          (state.filterV1Failed ? ' checked' : '') +
          ' />' +
          'V1 未通过</label>' +
          (state.filterV1Failed
            ? '<label class="filter-checkbox">' +
              '<input type="checkbox" data-action="filter-v2"' +
              (state.filterV2Failed ? ' checked' : '') +
              ' />' +
              'V2 未通过</label>'
            : '') +
          dimensionFilterControls +
          '<button class="ghost" data-action="clear-detail-filters"' +
          (derived.hasDetailFilters ? '' : ' disabled') +
          '>取消筛选</button>' +
          '<span class="muted filter-summary">筛选后 ' +
          detailRows.length +
          ' / ' +
          derived.activeRows.length +
          ' 行</span>' +
          '</div>' +
          (!detailRows.length
            ? '<div class="empty">当前筛选条件下没有符合的数据，点击“取消筛选”可查看全部。</div>'
            : '<div>' +
              '<div class="row-nav">' +
              '<button class="ghost" data-action="prev-row"' +
              (derived.canPrevRow ? '' : ' disabled') +
              '>上一行</button>' +
              '<button class="ghost" data-action="next-row"' +
              (derived.canNextRow ? '' : ' disabled') +
              '>下一行</button>' +
              '</div>' +
              '<p class="row-meta muted">' +
              escapeHtml(buildRowMetaText(currentRow, derived.activeSchema)) +
              '</p>' +
              '<div class="stage-tabs">' +
              stageTabs +
              '</div>' +
              '<div class="slider-wrapper">' +
              '<button class="ghost slider-arrow" data-action="prev-stage"' +
              (derived.canPrevStage ? '' : ' disabled') +
              '>◀</button>' +
              '<div class="slider-viewport">' +
              '<div class="slider-track" style="transform: translateX(-' +
              state.currentStageIndex * 100 +
              '%);">' +
              stagePanes +
              '</div>' +
              '</div>' +
              '<button class="ghost slider-arrow" data-action="next-stage"' +
              (derived.canNextStage ? '' : ' disabled') +
              '>▶</button>' +
              '</div>' +
              '</div>')
        );
      }

      function renderAnalysisViewer(derived) {
        const modelStatsPages = derived.modelStatsPages;
        const activeModelStats = derived.activeModelStats;

        if (!modelStatsPages.length) {
          return '<div class="empty">该条目没有可展示的模型分析结果。</div>';
        }
        if (!activeModelStats) {
          return '';
        }

        const dimensionTableHtml = activeModelStats.dimensionSections
          .map((section) => {
            const rowsHtml = section.rates.length
              ? section.rates
                  .map((item) => {
                    return (
                      '<tr>' +
                      '<td>' +
                      escapeHtml(item.name) +
                      '</td>' +
                      '<td>' +
                      escapeHtml(formatRate(item.rate)) +
                      '</td>' +
                      '<td>' +
                      item.pass +
                      ' / ' +
                      item.total +
                      '</td>' +
                      '</tr>'
                    );
                  })
                  .join('')
              : '<tr><td colspan="3" class="empty">' + escapeHtml(section.emptyText) + '</td></tr>';

            return (
              '<div class="analysis-table-wrap">' +
              '<h4>' +
              escapeHtml(section.title) +
              '</h4>' +
              '<table class="table compact-table">' +
              '<thead><tr><th>' +
              escapeHtml(section.columnLabel) +
              '</th><th>通过率</th><th>通过 / 总数</th></tr></thead>' +
              '<tbody>' +
              rowsHtml +
              '</tbody>' +
              '</table>' +
              '</div>'
            );
          })
          .join('');

        return (
          '<div class="analysis-nav">' +
          '<button class="ghost" data-action="prev-model"' +
          (derived.canPrevModel ? '' : ' disabled') +
          '>上一模型</button>' +
          '<span>第 ' +
          (state.currentModelIndex + 1) +
          ' / ' +
          modelStatsPages.length +
          ' 页</span>' +
          '<button class="ghost" data-action="next-model"' +
          (derived.canNextModel ? '' : ' disabled') +
          '>下一模型</button>' +
          '</div>' +
          '<div class="analysis-heading">' +
          '<h4>模型：' +
          escapeHtml(activeModelStats.model) +
          '</h4>' +
          '<p class="muted">按模型汇总当前筛选范围内的通过率统计。</p>' +
          '</div>' +
          '<div class="stats-grid analysis-kpis">' +
          '<article class="stat-card">' +
          '<h3>生成题目总数</h3>' +
          '<p class="stat-value">' +
          activeModelStats.totalRows +
          '</p>' +
          '</article>' +
          '<article class="stat-card">' +
          '<h3>Validator-1 通过率</h3>' +
          '<p class="stat-value">' +
          escapeHtml(formatRate(activeModelStats.validator1PassRate)) +
          '</p>' +
          '<p class="muted">' +
          activeModelStats.validator1PassCount +
          ' / ' +
          activeModelStats.totalRows +
          '</p>' +
          '</article>' +
          '<article class="stat-card">' +
          '<h3>Validator-2 通过率（不含 V1 已通过）</h3>' +
          '<p class="stat-value">' +
          escapeHtml(formatRate(activeModelStats.validator2PassRate)) +
          '</p>' +
          '<p class="muted">' +
          activeModelStats.validator2PassCount +
          ' / ' +
          activeModelStats.validator2BaseCount +
          '</p>' +
          '</article>' +
          '<article class="stat-card">' +
          '<h3>总通过率</h3>' +
          '<p class="stat-value">' +
          escapeHtml(formatRate(activeModelStats.totalPassRate)) +
          '</p>' +
          '<p class="muted">' +
          activeModelStats.totalPassCount +
          ' / ' +
          activeModelStats.totalRows +
          '</p>' +
          '</article>' +
          '</div>' +
          dimensionTableHtml
        );
      }

      function deriveState() {
        const activeEntry = state.entries.find((item) => item.id === state.activeEntryId) || null;
        const activeSchema = getSchemaByKey(activeEntry ? activeEntry.schemaKey : '');
        const activeRows = Array.isArray(activeEntry && activeEntry.rows) ? activeEntry.rows : [];
        const fieldFilteredRows = getRowsByFieldFilters(activeRows, activeSchema);
        const detailRows = getDetailRows(fieldFilteredRows);
        const modelStatsPages = buildModelStats(fieldFilteredRows, activeSchema);
        const stages = activeSchema.stageDefs;

        return {
          activeEntry: activeEntry,
          activeSchema: activeSchema,
          stages: stages,
          activeRows: activeRows,
          fieldFilteredRows: fieldFilteredRows,
          detailRows: detailRows,
          currentRow: detailRows[state.currentRowIndex] || null,
          modelStatsPages: modelStatsPages,
          activeModelStats: modelStatsPages[state.currentModelIndex] || null,
          dimensionFilterOptions: buildDimensionFilterOptions(activeRows, activeSchema),
          hasDetailFilters: state.filterV1Failed || state.filterV2Failed || hasActiveFieldFilters(activeSchema),
          canPrevRow: state.currentRowIndex > 0,
          canNextRow: state.currentRowIndex < detailRows.length - 1,
          canPrevStage: state.currentStageIndex > 0,
          canNextStage: state.currentStageIndex < stages.length - 1,
          canPrevModel: state.currentModelIndex > 0,
          canNextModel: state.currentModelIndex < modelStatsPages.length - 1
        };
      }

      function normalizeUiState() {
        if (state.viewerMode !== 'detail' && state.viewerMode !== 'analysis') {
          state.viewerMode = 'detail';
        }

        if (!state.filterV1Failed) {
          state.filterV2Failed = false;
        }

        if (!Array.isArray(state.entries)) {
          state.entries = [];
        }

        if (!state.detailFieldFilters || typeof state.detailFieldFilters !== 'object') {
          state.detailFieldFilters = {};
        }

        if (!state.entries.some((item) => item.id === state.expandedEntryId)) {
          state.expandedEntryId = '';
        }

        const activeEntry = state.entries.find((item) => item.id === state.activeEntryId) || null;
        if (!activeEntry) {
          state.activeEntryId = '';
          state.isViewerVisible = false;
        }

        const activeSchema = getSchemaByKey(activeEntry ? activeEntry.schemaKey : '');
        const validFilterKeys = new Set(activeSchema.filterFields.map((item) => item.key));
        Object.keys(state.detailFieldFilters).forEach((key) => {
          if (!validFilterKeys.has(key)) {
            delete state.detailFieldFilters[key];
            return;
          }
          state.detailFieldFilters[key] = String(state.detailFieldFilters[key] || '');
        });

        state.currentStageIndex = clamp(state.currentStageIndex, 0, activeSchema.stageDefs.length - 1);

        const activeRows = Array.isArray(activeEntry && activeEntry.rows) ? activeEntry.rows : [];
        const fieldFilteredRows = getRowsByFieldFilters(activeRows, activeSchema);
        const detailRows = getDetailRows(fieldFilteredRows);
        const modelStatsPages = buildModelStats(fieldFilteredRows, activeSchema);

        state.currentRowIndex = detailRows.length ? clamp(state.currentRowIndex, 0, detailRows.length - 1) : 0;
        state.currentModelIndex = modelStatsPages.length ? clamp(state.currentModelIndex, 0, modelStatsPages.length - 1) : 0;
      }

      function loadEntries() {
        try {
          const raw = window.localStorage.getItem(STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.map(normalizeEntry).filter(Boolean);
        } catch (error) {
          return [];
        }
      }

      function normalizeEntry(entry) {
        if (!entry || typeof entry !== 'object') return null;
        if (!Array.isArray(entry.rows)) return null;
        const schema = resolveEntrySchema(entry);
        const normalizedRows = entry.rows.map((row) => {
          const mapped = {};
          schema.knownHeaders.forEach((header) => {
            mapped[header] = row && row[header] !== undefined && row[header] !== null ? row[header] : '';
          });
          return mapped;
        });
        return {
          id: String(entry.id || ''),
          fileName: String(entry.fileName || 'unknown.csv'),
          uploadedAt: String(entry.uploadedAt || ''),
          rowCount: Number(entry.rowCount !== undefined ? entry.rowCount : normalizedRows.length) || normalizedRows.length,
          schemaKey: schema.key,
          rows: normalizedRows
        };
      }

      function persistEntries(nextEntries) {
        try {
          window.localStorage.setItem(STORAGE_KEY, JSON.stringify(nextEntries));
          return true;
        } catch (error) {
          state.errorMessage = '写入浏览器缓存失败，可能是本地存储空间不足。';
          return false;
        }
      }

      async function handleFileUpload(event) {
        const file = event && event.target && event.target.files && event.target.files[0];
        if (!file) return;
        resetMessages();
        render();

        try {
          const text = await file.text();
          const parsed = parseCsv(text);
          if (!parsed.length) {
            throw new Error('CSV 为空，无法导入。');
          }

          const headers = parsed[0].map((value, index) => {
            const textValue = String(value !== undefined && value !== null ? value : '');
            if (index === 0 && textValue.charCodeAt(0) === 0xfeff) {
              return textValue.slice(1).trim();
            }
            return textValue.trim();
          });

          const schemaMatch = detectSchemaByHeaders(headers);
          if (!schemaMatch.schema) {
            throw new Error(schemaMatch.error);
          }

          const rows = parsed
            .slice(1)
            .filter(hasAnyCellValue)
            .map((row) => mapRowToObject(schemaMatch.schema, headers, row));

          const nextEntry = {
            id: createEntryId(),
            fileName: file.name || 'uploaded.csv',
            uploadedAt: new Date().toISOString(),
            rowCount: rows.length,
            schemaKey: schemaMatch.schema.key,
            rows: rows
          };

          const nextEntries = [nextEntry].concat(state.entries);
          if (!persistEntries(nextEntries)) {
            normalizeUiState();
            render();
            return;
          }

          state.entries = nextEntries;
          state.expandedEntryId = nextEntry.id;
          state.isViewerVisible = false;
          state.successMessage = '导入成功：' + nextEntry.fileName + '（' + rows.length + ' 行，' + schemaMatch.schema.label + '）';
        } catch (error) {
          state.errorMessage = error && error.message ? error.message : '导入失败，请检查文件格式。';
        } finally {
          if (event && event.target) {
            event.target.value = '';
          }
          normalizeUiState();
          render();
        }
      }

      function createEntryId() {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
          return crypto.randomUUID();
        }
        return Date.now() + '-' + Math.random().toString(36).slice(2, 10);
      }

      function detectSchemaByHeaders(headers) {
        const headerSet = new Set(headers);
        const matches = SCHEMA_KEYS
          .map((key) => SCHEMA_CONFIG[key])
          .filter((schema) => schema.requiredHeaders.every((field) => headerSet.has(field)));

        if (!matches.length) {
          const lines = SCHEMA_KEYS.map((key) => {
            const schema = SCHEMA_CONFIG[key];
            const missing = schema.requiredHeaders.filter((field) => !headerSet.has(field));
            return ' - ' + schema.label + ' 缺少字段：' + (missing.length ? missing.slice(0, 8).join(', ') + (missing.length > 8 ? ' ...' : '') : '无');
          });
          return {
            schema: null,
            error: 'CSV 不匹配已支持的实验类型，无法导入。\n' + lines.join('\n')
          };
        }

        matches.sort((a, b) => b.requiredHeaders.length - a.requiredHeaders.length);
        return { schema: matches[0], error: '' };
      }

      function mapRowToObject(schema, headers, row) {
        const mapped = {};
        schema.knownHeaders.forEach((header) => {
          mapped[header] = '';
        });
        headers.forEach((header, index) => {
          if (!Object.prototype.hasOwnProperty.call(mapped, header)) return;
          mapped[header] = row[index] !== undefined && row[index] !== null ? row[index] : '';
        });
        return mapped;
      }

      function hasAnyCellValue(row) {
        return row.some((cell) => String(cell !== undefined && cell !== null ? cell : '').trim() !== '');
      }

      function parseCsv(content) {
        const rows = [];
        let row = [];
        let cell = '';
        let inQuotes = false;

        for (let i = 0; i < content.length; i += 1) {
          const char = content[i];

          if (inQuotes) {
            if (char === '"') {
              if (content[i + 1] === '"') {
                cell += '"';
                i += 1;
              } else {
                inQuotes = false;
              }
            } else {
              cell += char;
            }
            continue;
          }

          if (char === '"') {
            if (!cell) {
              inQuotes = true;
            } else {
              cell += char;
            }
            continue;
          }

          if (char === ',') {
            row.push(cell);
            cell = '';
            continue;
          }

          if (char === '\n') {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = '';
            continue;
          }

          if (char === '\r') {
            if (content[i + 1] !== '\n') {
              row.push(cell);
              rows.push(row);
              row = [];
              cell = '';
            }
            continue;
          }

          cell += char;
        }

        if (inQuotes) {
          throw new Error('CSV 格式错误：存在未闭合的双引号。');
        }

        if (cell.length || row.length) {
          row.push(cell);
          rows.push(row);
        }

        while (
          rows.length &&
          rows[rows.length - 1].every((value) => String(value !== undefined && value !== null ? value : '').trim() === '')
        ) {
          rows.pop();
        }

        return rows;
      }

      function buildModelStats(rows, schema) {
        if (!Array.isArray(rows) || !rows.length) return [];
        const modelMap = new Map();
        const activeSchema = schema || getSchemaByKey('');

        rows.forEach((row) => {
          const model = normalizeDimension(row ? row.generator_model : '', '未标注模型');
          const modelRows = modelMap.get(model) || [];
          modelRows.push(row);
          modelMap.set(model, modelRows);
        });

        return Array.from(modelMap.entries())
          .map((entry) => buildSingleModelStats(entry[0], entry[1], activeSchema))
          .sort((a, b) => {
            if (b.totalRows !== a.totalRows) return b.totalRows - a.totalRows;
            return a.model.localeCompare(b.model, 'zh-Hans-CN');
          });
      }

      function buildSingleModelStats(model, rows, schema) {
        let validator1PassCount = 0;
        let validator2BaseCount = 0;
        let validator2PassCount = 0;
        let totalPassCount = 0;
        const dimensionMaps = (schema.analysisDimensions || []).map((dimension) => {
          return {
            config: dimension,
            map: new Map()
          };
        });

        rows.forEach((row) => {
          const validator1Pass = isValidatorPass(row, 'validator_1');
          const validator2Pass = isValidatorPass(row, 'validator_2');
          const finalPass = validator1Pass || (!validator1Pass && validator2Pass);

          if (validator1Pass) {
            validator1PassCount += 1;
          } else {
            validator2BaseCount += 1;
            if (validator2Pass) {
              validator2PassCount += 1;
            }
          }

          if (finalPass) {
            totalPassCount += 1;
          }

          dimensionMaps.forEach((item) => {
            const normalized = normalizeDimension(row ? row[item.config.key] : '', item.config.fallback || '未标注');
            accumulateDimension(item.map, normalized, finalPass);
          });
        });

        const dimensionSections = dimensionMaps.map((item) => {
          return {
            key: item.config.key,
            title: item.config.title,
            columnLabel: item.config.columnLabel,
            emptyText: item.config.emptyText,
            rates: toDimensionRates(item.map)
          };
        });

        return {
          model: model,
          totalRows: rows.length,
          validator1PassCount: validator1PassCount,
          validator1PassRate: calcRate(validator1PassCount, rows.length),
          validator2BaseCount: validator2BaseCount,
          validator2PassCount: validator2PassCount,
          validator2PassRate: calcRate(validator2PassCount, validator2BaseCount),
          totalPassCount: totalPassCount,
          totalPassRate: calcRate(totalPassCount, rows.length),
          dimensionSections: dimensionSections
        };
      }

      function isValidatorPass(row, prefix) {
        return parseBoolean(row ? row[prefix + '_is_valid'] : '') && parseBoolean(row ? row[prefix + '_has_unique_answer'] : '');
      }

      function parseBoolean(value) {
        if (typeof value === 'boolean') return value;
        const normalized = String(value !== undefined && value !== null ? value : '').trim().toLowerCase();
        return normalized === 'true' || normalized === '1' || normalized === 'yes';
      }

      function accumulateDimension(map, key, passed) {
        const current = map.get(key) || { total: 0, pass: 0 };
        current.total += 1;
        if (passed) {
          current.pass += 1;
        }
        map.set(key, current);
      }

      function toDimensionRates(map) {
        return Array.from(map.entries())
          .map((entry) => {
            const name = entry[0];
            const stats = entry[1];
            return {
              name: name,
              total: stats.total,
              pass: stats.pass,
              rate: calcRate(stats.pass, stats.total)
            };
          })
          .sort((a, b) => {
            const rateA = a.rate === null || a.rate === undefined ? Number.POSITIVE_INFINITY : a.rate;
            const rateB = b.rate === null || b.rate === undefined ? Number.POSITIVE_INFINITY : b.rate;
            if (rateA !== rateB) return rateA - rateB;
            return a.name.localeCompare(b.name, 'zh-Hans-CN');
          });
      }

      function calcRate(numerator, denominator) {
        if (!denominator) return null;
        return numerator / denominator;
      }

      function normalizeDimension(value, fallback) {
        const text = String(value !== undefined && value !== null ? value : '').trim();
        return text || fallback;
      }

      function toggleEntryAccordion(id) {
        state.expandedEntryId = state.expandedEntryId === id ? '' : id;
        normalizeUiState();
        render();
      }

      function openEntry(id, mode) {
        state.activeEntryId = id;
        state.expandedEntryId = id;
        state.isViewerVisible = true;
        state.viewerMode = mode === 'analysis' ? 'analysis' : 'detail';
        state.currentRowIndex = 0;
        state.currentStageIndex = 0;
        state.currentModelIndex = 0;
        state.detailFieldFilters = {};
        resetMessages();
        normalizeUiState();
        render();
      }

      function removeEntry(id) {
        if (!window.confirm('确认删除该上传条目吗？')) return;
        const nextEntries = state.entries.filter((item) => item.id !== id);
        if (!persistEntries(nextEntries)) {
          normalizeUiState();
          render();
          return;
        }

        state.entries = nextEntries;

        if (state.activeEntryId === id) {
          state.activeEntryId = '';
          state.isViewerVisible = false;
          state.viewerMode = 'detail';
          state.currentRowIndex = 0;
          state.currentStageIndex = 0;
          state.currentModelIndex = 0;
          state.detailFieldFilters = {};
        }
        if (state.expandedEntryId === id) {
          state.expandedEntryId = '';
        }
        normalizeUiState();
        render();
      }

      function clearEntries() {
        if (!state.entries.length) return;
        if (!window.confirm('确认清空所有实验结果缓存吗？')) return;
        if (!persistEntries([])) {
          normalizeUiState();
          render();
          return;
        }

        state.entries = [];
        state.activeEntryId = '';
        state.expandedEntryId = '';
        state.isViewerVisible = false;
        state.viewerMode = 'detail';
        state.currentRowIndex = 0;
        state.currentStageIndex = 0;
        state.currentModelIndex = 0;
        state.detailFieldFilters = {};
        resetMessages();
        normalizeUiState();
        render();
      }

      function goPrevRow() {
        const derived = deriveState();
        if (!derived.canPrevRow) return;
        state.currentRowIndex -= 1;
        normalizeUiState();
        render();
      }

      function goNextRow() {
        const derived = deriveState();
        if (!derived.canNextRow) return;
        state.currentRowIndex += 1;
        normalizeUiState();
        render();
      }

      function goToStage(index) {
        const activeEntry = state.entries.find((item) => item.id === state.activeEntryId) || null;
        const activeSchema = getSchemaByKey(activeEntry ? activeEntry.schemaKey : '');
        state.currentStageIndex = clamp(index, 0, activeSchema.stageDefs.length - 1);
        normalizeUiState();
        render();
      }

      function goPrevStage() {
        const derived = deriveState();
        if (!derived.canPrevStage) return;
        state.currentStageIndex -= 1;
        normalizeUiState();
        render();
      }

      function goNextStage() {
        const derived = deriveState();
        if (!derived.canNextStage) return;
        state.currentStageIndex += 1;
        normalizeUiState();
        render();
      }

      function clearDetailFilters() {
        state.filterV1Failed = false;
        state.filterV2Failed = false;
        state.detailFieldFilters = {};
        state.currentRowIndex = 0;
        state.currentModelIndex = 0;
        normalizeUiState();
        render();
      }

      function setViewerMode(mode) {
        state.viewerMode = mode === 'analysis' ? 'analysis' : 'detail';
        if (state.viewerMode === 'analysis') {
          state.currentModelIndex = 0;
        }
        normalizeUiState();
        render();
      }

      function goPrevModel() {
        const derived = deriveState();
        if (!derived.canPrevModel) return;
        state.currentModelIndex -= 1;
        normalizeUiState();
        render();
      }

      function goNextModel() {
        const derived = deriveState();
        if (!derived.canNextModel) return;
        state.currentModelIndex += 1;
        normalizeUiState();
        render();
      }

      function getDetailRows(activeRows) {
        if (!activeRows.length) return [];
        if (!state.filterV1Failed) return activeRows;
        return activeRows.filter((row) => {
          if (isValidatorPass(row, 'validator_1')) return false;
          if (state.filterV2Failed && isValidatorPass(row, 'validator_2')) return false;
          return true;
        });
      }

      function getRowsByFieldFilters(rows, schema) {
        if (!Array.isArray(rows) || !rows.length) return [];
        const activeFilters = (schema.filterFields || []).filter((field) => {
          const selected = String(state.detailFieldFilters[field.key] || '');
          return selected !== '';
        });
        if (!activeFilters.length) return rows;

        return rows.filter((row) => {
          return activeFilters.every((field) => {
            const selected = String(state.detailFieldFilters[field.key] || '');
            const rowValue = String(row && row[field.key] !== undefined && row[field.key] !== null ? row[field.key] : '').trim();
            if (selected === EMPTY_FILTER_VALUE) {
              return rowValue === '';
            }
            return rowValue === selected;
          });
        });
      }

      function buildDimensionFilterOptions(rows, schema) {
        if (!Array.isArray(schema.filterFields) || !schema.filterFields.length) return [];

        return schema.filterFields.map((filterField) => {
          const valueSet = new Set();
          let hasEmpty = false;
          rows.forEach((row) => {
            const value = String(row && row[filterField.key] !== undefined && row[filterField.key] !== null ? row[filterField.key] : '').trim();
            if (!value) {
              hasEmpty = true;
              return;
            }
            valueSet.add(value);
          });

          const options = Array.from(valueSet)
            .sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'))
            .map((value) => {
              return { value: value, label: value };
            });

          if (hasEmpty) {
            options.unshift({ value: EMPTY_FILTER_VALUE, label: filterField.emptyLabel || '(空)' });
          }

          return {
            key: filterField.key,
            label: filterField.label,
            allLabel: filterField.allLabel || '全部',
            currentValue: String(state.detailFieldFilters[filterField.key] || ''),
            options: options
          };
        });
      }

      function hasActiveFieldFilters(schema) {
        return (schema.filterFields || []).some((filterField) => {
          return String(state.detailFieldFilters[filterField.key] || '') !== '';
        });
      }

      function buildRowMetaText(row, schema) {
        const parts = [];
        parts.push('动词：' + formatFieldValue(row ? row.verb_infinitive : ''));
        (schema.rowMetaFields || []).forEach((field) => {
          parts.push(field.label + '：' + formatFieldValue(row ? row[field.key] : ''));
        });
        return parts.join(' ｜ ');
      }

      function getSchemaByKey(schemaKey) {
        if (schemaKey && SCHEMA_CONFIG[schemaKey]) {
          return SCHEMA_CONFIG[schemaKey];
        }
        return SCHEMA_CONFIG[DEFAULT_SCHEMA_KEY];
      }

      function getSchemaLabel(schemaKey) {
        return getSchemaByKey(schemaKey).label;
      }

      function resolveEntrySchema(entry) {
        const explicitSchema = getSchemaByKey(entry && entry.schemaKey ? entry.schemaKey : '');
        if (entry && entry.schemaKey && SCHEMA_CONFIG[entry.schemaKey]) {
          return explicitSchema;
        }
        const sampleRow = entry && Array.isArray(entry.rows) && entry.rows.length ? entry.rows[0] : null;
        if (!sampleRow) {
          return explicitSchema;
        }
        const detected = detectSchemaByHeaders(Object.keys(sampleRow));
        return detected.schema || explicitSchema;
      }

      function mapStages(stages) {
        return (stages || []).map((stage) => {
          return {
            key: stage.key,
            title: stage.title,
            description: stage.description,
            fields: (stage.fields || []).map((fieldKey) => {
              return {
                key: fieldKey,
                label: FIELD_LABELS[fieldKey] || fieldKey
              };
            })
          };
        });
      }

      function collectSchemaHeaders(schema) {
        const allHeaders = [];
        (schema.requiredHeaders || []).forEach((header) => allHeaders.push(header));
        (schema.stages || []).forEach((stage) => {
          (stage.fields || []).forEach((field) => allHeaders.push(field));
        });
        (schema.filterFields || []).forEach((field) => allHeaders.push(field.key));
        (schema.rowMetaFields || []).forEach((field) => allHeaders.push(field.key));
        (schema.analysisDimensions || []).forEach((field) => allHeaders.push(field.key));
        return uniqueList(allHeaders);
      }

      function uniqueList(list) {
        const seen = new Set();
        const output = [];
        (list || []).forEach((item) => {
          const text = String(item || '');
          if (!text || seen.has(text)) return;
          seen.add(text);
          output.push(text);
        });
        return output;
      }

      function formatDate(value) {
        if (!value) return '-';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toLocaleString();
      }

      function formatFieldValue(value) {
        if (isEmptyValue(value)) return '—';
        return String(value);
      }

      function formatRate(rate) {
        if (rate === null || rate === undefined) return '-';
        return (rate * 100).toFixed(2) + '%';
      }

      function isEmptyValue(value) {
        return value === null || value === undefined || String(value).trim() === '';
      }

      function resetMessages() {
        state.errorMessage = '';
        state.successMessage = '';
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function clamp(value, min, max) {
        if (Number.isNaN(value)) return min;
        return Math.min(Math.max(value, min), max);
      }
    })();
  </script>
</body>
</html>
